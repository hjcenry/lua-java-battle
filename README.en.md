# Java-lua battle framework

![Powered][1]]

[1]: https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/lua/lua.png

[中文文档](https://github.com/hjcenry/lua-java-battle/blob/master/README.md)

> **Java based on LuaJ uses Lua's battle framework**

The framework is based on the secondary encapsulation implementation of LuaJ(https://luaj.sourceforge.net)

# It provides the following functions

- Call encapsulation of LuAj's base interface
- Simplify the setup of the LuaJ environment
- Manages Lua battles and provides interfaces
- Lua object-oriented usage scheme(class.lua)
- [Example of Lua combat framework](https://github.com/hjcenry/lua-java-battle/src/main/test/com/hjc/demo/service/BattleDemoService.java)
- Luaj's Guide to stomping pits

This framework provides a Java-Lua battle framework with the following advantages and disadvantages

- **Advantages**:

1. Common logic LUA code: The front and rear end can use the same set of combat logic code based on the same set of language, just need to design the common war framework, can realize one piece of code used in two places. The front and back end programmers can also develop together based on this framework, which can improve the development efficiency to a certain extent for both state synchronization and frame synchronization.
2. The LuaJ framework is by far the most efficient way to invoke Lua in Java.
3. Lua code can be used directly without compilation, and you can design a set of hot logic through LuaJ

- **Disadvantages**（**Guidelines on pit**）:

1. More heap and meta space for the JVM

Luaj provides two compilers, LuaC and LuaJC. Luac will create a LuaClosure object after the LOAD file, and it will parse the lua command line by line as it runs, but it won't run very efficiently.
The principle of LuaJc is to compile it into Java bytecode and load it into memory through its JavaLoader (inheriting ClassLoader), which is equivalent to compiling and running it many times.
However, those familiar with the Java class loading mechanism should know that during this process, the JVM creates Klass information in the Meta space and stores the Klass reference in the ClassLoader. Meanwhile, Luaj's JavaLoader also does one thing: cache dynamically generated bytecode byte[]
In this case, starting a Lua environment increases the heap and meta footprint of the JVM.

2. Not as efficient as native Java

The authors of LuAJ describe that LuAJ is almost as efficient or even more efficient than native Lua virtual machines. But in my actual tests, I didn't compare Luaj to native Lua, I compared Luaj to native Java, and the performance was far worse.
By observing the compiled source code of luaj, we can also find that an operation like i++, for example, can be directly operated on the basic data type int in Java, but in luaj, int is wrapped by the Integer wrapper class (LuaInteger).

- Both a strength and a weakness
1. Flexible Lua code

Flexibility is a double-edged sword. If used well, it can greatly improve development efficiency. If not used well, it can not only improve development efficiency, but also bring great pain to development and maintenance, which is very important for the ability of low-level development.

> **From what has been discussed above**:Whether you want to use Lua as your Java server's combat logic code depends on the situation, whether the advantages of Lua give you great benefits of your code and you can live with its disadvantages or have other solutions to overcome its disadvantages.

`Welcome to use, any bugs and optimization requirements, welcome to discuss issues`

# Java Doc

https://hjcenry.com/lua-java-battle/doc/

# Quick Start

See BattleDemoService for a complete code example

# Maven repositories

```xml
<dependency>
    <groupId>io.github.hjcenry</groupId>
    <artifactId>lua-java-battle</artifactId>
    <version>1.0</version>
</dependency>
```

## 1. Specify the Lua parameter

```java
LuaInit.LuaInitBuilder luaInit=LuaInit.builder();
luaInit.preScript("print('Hello Lua Battle!!!')");
// Set the Lua root path
luaInit.luaRootPath("F:\\project\\lua-java-battle\\src\\main\\lua\\");
// Load the Lua call interface directory
luaInit.luaLoadDirectories("interface");
// Load the Lua main file
luaInit.luaLoadFiles("FightManager.lua");
// Show log
luaInit.showLog(true);
```

## 2. Initialize the Lua environment

```java
LuaBattleManager.getInstance().init(luaInit.build());
```

## 3. Initialize and cache Lua methods called by Java

```java
// All the methods you need to start with
this.xxxFunction=this.initFunction("XXX.xxx");
this.xxxFunction2=this.initFunction("xxx");
```

## 4. Call Lua methods

```java
this.xxxFunction.invoke();
this.xxxFunction2.invoke(LuaNumber.valueOf(123));
```

> `The above is a simple example of how this framework should be used. BattleDemoService provides a set of examples comparing the completion of the Lua combat framework`

# How to use and examples

1. [Battle Service Example](https://github.com/hjcenry/lua-java-battle/src/main/test/com/hjc/demo/service/BattleDemoService.java)
2. [Example of Lua-Java data conversion tool](https://github.com/hjcenry/lua-java-battle/src/main/test/com/hjc/demo/conver/ConvertModelLuaFileTest.java)
3. [Example of Lua-Java library conversion tool](https://github.com/hjcenry/lua-java-battle/src/main/test/com/hjc/demo/conver/ConvertLibLuaFileTest.java)

# The relevant data

1. https://www.lua.org/ lua官网
2. https://luaj.sourceforge.net luaj官网

# Communication

- Wechat:hjcenry